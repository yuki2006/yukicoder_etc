<title>アルゴリズムの簡単なまとめ</title>
<h4 class="shadow">アルゴリズムの簡単なまとめ</h4>

運営者が昔、メモ程度にどこかに書いてたものです。間違っている箇所がありましたら教えて下さい。<br />
順次追加・修正中(ページごとに分けてもいいし、良いページができたら削除したい)<br />


<ul>
	<li>計算手段</li>
	<ul>
		<li>再帰呼び出し</li>
		<ul>
			<li>自分自身の関数を呼び出すこと、forやwhileのループでもできることが、再帰呼び出しのほうが記述しやすいこともある。</li>
			<li>末尾再帰</li>
			<ul>
				<li>return に再帰関数を呼び出すこと、return以外に再帰呼び出しがないこと<br>
					注意としては再帰の結果をすぐにreturnすること(再帰の結果を更に演算したりなどはNGのはず）<br>
					動き的には末尾の再帰のreturnをすると、それ以降returnの処理しかないような動き。
				</li>
				<li>これをする理由は、（言語によってはしてくれない）末尾再帰最適化が働き、一つのfor文に変換してくれて、再帰でネックのスタックのコストを削減できる。</li>
			</ul>
		</ul>
	</ul>
	<li>数学的アルゴリズム</li>
	<ul>
		<li>最大公約数 (GCD)</li>
		<ul>
			<li><a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95">ユークリッド互除法</a></li>
			<li>全ての素因数の指数に対してminを取ることに該当する</li>
		</ul>
		<li>最小公倍数 (LCM)</li>
		<ul>
			<li>lcm(a,b) = a*b / gcd(a,b) で求められる。滅多にないがlcm(a,b)はオーバーフローしないがa*bはオーバーフローする可能性がある場合はlcm(a,b) = a / gcd(a,b) * b とする</li>
			<li>全ての素因数の指数に対してmaxを取ることに該当する</li>
		</ul>
		<li>素数を求める(Prime Number)</li>
		<ul>
			<li>素数は2,3以外は　6n+1または6n-1の数である。これを知っていると下の2つのアルゴリズムで更に早く求められるかも知れない。</li>
			<li>試し割り</li>
			<ul>
				<li>2～n-1までで余りが出るかどうか求めて、全てあまりが出れば素数(実は2～√nまでで良い）</li>
				<li>実装は楽</li>
			</ul>
			<li><a href="http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9" target="_blank">エラトステネスの篩</a></li>
			<ul>
				<li>素数表（1～nまでの各整数が素数かどうかを全て判定する）を作る。</li>
				<li>たくさんの数を判定する場合はこちらが良い。</li>
				<li>1～nまでの全ての整数に対して約数の数を求めるなどと言った時も同様の考え方をすることができ、色々な問題に適応可能。</li>
			</ul>
			<li>区間篩</li>
			<ul>
				<li>素数表（L～Rまでの各整数が素数かどうかを全て判定する）を作る。</li>
				<li>制約に $R \leq 10^{12}, \;\; R-L \leq 10^6$ などというのを見かけたらこのテクニック（あるいはこの応用）が使える可能性がある。</li>
			</ul>
		</ul>
		<li><a href="http://ja.wikipedia.org/wiki/%E5%86%AA%E5%89%B0%E4%BD%99">冪剰余</a></li>
		<ul>
			<li>$a^N$ を計算し、kで割ったあまりを求める問題。　普通にaのN乗を計算するとオーバーフローしたり、多倍長計算が出来ても重い、あまりを一つの掛け算ごとに行ったりテクニックを使うとO(log N)で計算可能になる。</li>
		</ul>
		<li><a href="http://ja.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E6%A0%B9" target="_blank">数字根</a></li>
		<ul>
			<li>ある数値を表す数字を全て足し、結果の数値の数字を全て足し、という操作を繰り返し、最終的に得られる一桁の数字のこと。<br>
			</li>
			<li>実はあまりを場合分けするだけですぐに求められる。（Wikipediaの合同式による定義を参考）</li>
		</ul>
		<li><a href="http://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A7%E3%83%AB%E3%83%9E%E3%83%BC%E3%81%AE%E5%B0%8F%E5%AE%9A%E7%90%86">フェルマーの小定理</a></li>
	</ul>
	<li>グラフ</li>
	<ul>
		<li>頂点と頂点同士をつないだ辺を持ったもの</li>
		<li>歩道・ウォーク (walk)</li>
		<ul>
		    <li>頂点と辺が交互に現れる列であって、最初と最後は頂点で、辺の両端点は左右の頂点をつないでいるものをいう</li>
		    <li>歩道が 閉じている (closed) とは、最初の頂点と最後の頂点が同じであることをいい、それを閉歩道という</li>
		</ul>
		<li>小道・トレイル (trail)</li>
		<ul>
		    <li>歩道のうち、同じ辺を2度以上通らないもの</li>
			<li><a href="http://ja.wikipedia.org/wiki/%E3%82%AA%E3%82%A4%E3%83%A9%E3%83%BC%E8%B7%AF" target="_blank">オイラー路</a>（オイラーグラフ）</li>
			<ul>
				<li>小道のうち、すべての辺をちょうど1回ずつ通るもの（一筆書き問題）</li>
			</ul>
		</ul>
		<li>パス・道・路 (path)</li>
		<ul>
		    <li>歩道のうち、同じ頂点を2度以上通らないもの。明らかに、パスは小道である</li>
		    <li>これを「単純パス (simple path)」と呼び、歩道または小道のことを単にパスと呼ぶ流儀もある</li>
			<li><a href="http://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%9F%E3%83%AB%E3%83%88%E3%83%B3%E8%B7%AF">ハミルトン路</a></li>
			<ul>
				<li>すべての頂点を1度ずつ通る路のこと</li>
				<li>与えられたグラフにハミルトン路が存在するかを判定する問題はNP完全である</li>
			</ul>
		</ul>
		<li>閉路・サイクル (cycle)</li>
		<ul>
		    <li>閉歩道のうち、最初の頂点だけを最初と最後でちょうど2度通り、それ以外の頂点は2度以上通らないものをいう</li>
			<li>ハミルトン閉路</li>
			<ul>
				<li>すべての頂点を1度ずつ通る閉路のこと</li>
			</ul>
		</ul>
		<li>無向グラフ</li>
		<ul>
			<li>辺に方向がないもの（どちら共に行ける）A-&gt;Bへも B-&gt;Aへも行ける</li>
			<li><a href="http://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)">木</a></li>
			<ul>
				<li><a href="http://ja.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9C%A8">二分木</a></li>
				<ul>
					<li><a href="http://www.sophia-it.com/content/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%88%86%E6%9C%A8">完全二分木</a></li>
				</ul>
				<li><a href="http://ja.wikipedia.org/wiki/%E5%85%A8%E5%9F%9F%E6%9C%A8" target="_blank">全域木</a></li>
				<ul>
					<li>すべての頂点が連結である（孤立がない）木のこと</li>
					<li>最小全域木(MST:Minimun Spanning Tree)問題</li>
					<ul>
						<li>すべての頂点が連結である（孤立がない）木にするための最小限のコストの辺だけ残したもの。</li>
						<li>（それぞれの道路にコストが有り、n個の村があってすべての村をつなげるために、最小限のコストの道だけ作る問題）</li>
						<li>無向グラフに対する最小全域木は貪欲法（プリム、クラスカル）で解けるが、有向グラフに関する最小全域木は簡単ではない。（始点を除いて、入ってくる枝の中でコスト最小のものだけを考え、閉路ができなければ終了、閉路ができたらその閉路を1つのノードにしてグラフを再構成するというのを繰り返すと有向グラフに対する最小全域木を求めることができる）</li>
					</ul>
					<li>与えられた無向グラフに含まれる全域木の数は行列式を用いて数え上げることができる</li>
				</ul>
			</ul>
		</ul>
		<li>有向グラフ</li>
		<ul>
			<li>辺に方向がないあるもの（行ける方向が決まっている一方通行） A-&gt;Bしかいけない　</li>
			<ul>
				<li>もちろんすべての辺で B-&gt;Aの辺もある場合は無向グラフと同等になる。</li>
			</ul>
			<li>DAG(directed acyclic graph)</li>
			<ul>
				<li>有向グラフで閉路（ループ）を持たないグラフ</li>
			</ul>
		</ul>
		<li>最大流、最小カット</li>
		<ul>
		    <li>Dinicが一般的に高速だが最悪ケースを作るのは難しくないので過信できない</li>
		</ul>
		<li>最小費用流</li>
		<ul>
		    <li>最短路を求めるアルゴリズムが色々考えられて難しい。一般的なグラフの場合は1回ベルマンフォードしてからポテンシャルを考慮したダイクストラをする</li>
		    <li>枝のコストが非負なら最初からダイクストラで高速。グラフが万が一DAGなんてときはDP一択。</li>
		    <li>コスト最小二部マッチングでグラフが密な場合は問答無用でハンガリアン法を使いましょう。</li>
		</ul>
		<li>有名な問題</li>
		<ul>
			<li><a href="http://ja.wikipedia.org/wiki/%E5%B7%A1%E5%9B%9E%E3%82%BB%E3%83%BC%E3%83%AB%E3%82%B9%E3%83%9E%E3%83%B3%E5%95%8F%E9%A1%8C">巡回セールスマン問題</a>(TSP)</li>
			<ul>
				<li>辺にコストが有り、すべての頂点を１回だけ通り、始点に帰ってくる経路（つまり閉路）の最短経路問題</li>
				<ul>
					<li>辺のコストが1または無限大（通れない）の条件がつくとハミルトン閉路</li>
					<li>NP困難</li>
				</ul>
			</ul>
			<li><a href="http://ja.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E4%BA%BA%E9%83%B5%E4%BE%BF%E9%85%8D%E9%81%94%E5%95%8F%E9%A1%8C" target="_blank">中国人郵便配達問題</a></li>
			<ul>
				<li>すべての辺を１回以上通る閉路の最短経路問題</li>
				<ul>
					<li>一般グラフの重み付き最大マッチング問題に還元することにより多項式時間で解くことができる</li>
				</ul>
			</ul>
		</ul>
	</ul>
	<li>データ構造</li>
	<ul>
		<li>連想配列・HashMap</li>
		<li>スタック(Stack)</li>
		<ul>
			<li>push（値を最後に入れる）/pop(最後の値を取り出して消す）の操作ができるデータ構造</li>
			<li>いわゆるLIFO(Last In First out)</li>
			<li>実装では、普通のリストを利用することもできるが、それ専用に最適化されたクラスもある言語もある。</li>
		</ul>
		<li>キュー(Queue)</li>
		<ul>
			<li>queue (最後に値を入れる)/dequeue(最初の値を取り出す）の操作ができるデータ構造</li>
			<li>いわゆるFIFO (First in First Out)　</li>
			<li>実装では、普通のリストを利用することもできるが、それ専用に最適化されたクラスもある言語もある。</li>
		</ul>
		<li>プライオリティキュー（優先度付きキュー）</li>
		<ul>
			<ul>
				<li>優先度を指定して、その順に取り出すことができる。</li>
				<li>一般的にプライオリティキューとなっているものは、dequeue時にO (log n)で取り出せる。</li>
			</ul>
		</ul>
		<li>Segment Tree</li>
		<ul>
			<li>区分ごとの値が計算可能な問題に対して（最小値/RMQ(Range Minimum Query)など）<br>
				区分ごとの計算を予めしておき、データ構造として保持する。
			</li>
			<li>値を更新するのは O (log n)<br>
				値を取得するのは O (log n)<br>
				で可能
			</li>
			<ul>
				<li>ちなみに配列での純粋な実装の場合は、値を更新するのは O (1)　値を取得するのは O (n)</li>
			</ul>
			<li>区間に対する演算を行い、区間に対するクエリを求める必要がある場合は、遅延評価をすることで両方とも $O(\log n)$ で行える</li>
			<li>区間が広い場合は、クエリを先読みして座標圧縮すると良い</li>
			<li>区間が広い、かつ、先読みも禁止されている場合（オンラインアルゴリズムが求められている場合）、初期値が一定でクエリが少ない場合は、必要なノードをそのたびに動的に作ることもで解決できることがある</li>
			<li>RMQなどで、更新しなくて良い場合は、スパーステーブルを用いたほうが高速（ただしメモリはたくさん必要となる）</li>
		</ul>
		<li>BIT、別名Fenwick Tree</li>
		<ul>
			<li>Segment Treeの応用</li>
			<li>1〜n の範囲に対しての計算ができる場合にデータ構造として保持する。</li>
			<li>例えば　ak~anの部分和のような問題によい。　sum(k,n)=S(n)-S(k)なので　Sを効率的に求める</li>
			<li>計算量的にはSegment Treeと同じだが、（ビットテクニックを知ってれば）実装はこちらのほうが楽（更にSegment Treeより1.5～2倍程度速いので想定解法でなくても通るかも）</li>
		</ul>
		<li>平衡二分木</li>
		<li>Link-Cut Tree</li>
		<li>永続データ構造</li>
		<li>平方分割</li>
		<ul>
			<li>複雑なデータ構造を実装しなくても、データをいくつかのまとまり（通常 $\sqrt{n}$ ぐらいずつ）にわけて保持することで色々な操作が $O(\sqrt{n})$ でできるようになることも。</li>
		</ul>
	</ul>
	<li>場合の数</li>
	<ul>
		<li>
			場合の数は大きくなることが多いので ${\rm mod}\ m$ で答え求めることが多い。$(a \pm b)\ {\rm mod}\ m = (a\ {\rm mod}\ m) \pm (b\ {\rm mod}\ m)$ や $(a \times b)\ {\rm mod}\ m = (a\ {\rm mod}\ m) \times (b\ {\rm mod}\ m)$ が成り立つことを忘れないように。また、$(a / b)\ {\rm mod}\ m = (a\ {\rm mod}\ m) / (a\ {\rm mod}\ m)$ は通常<b>成り立たない</b>ことには注意！（どうしてもなら、特に $m$ が素数なら逆元を用いることで割り算もできる）
		</li>
		<li>
			<a href='http://ja.wikipedia.org/wiki/%E5%8C%85%E9%99%A4%E5%8E%9F%E7%90%86' target='_blank'>包除原理</a>
		</li>
		<ul>
			<li>全体の数から、該当しない（重複している）数を取り除く原理である。<br>
				具体的には $|A \cup B| = |A| + |B|- |A \cap B|$ のような集合の公式を用いて数え上げること
			</li>
			<li>詳しくはwikipediaを参照のことだが、競技プログラミングにおいて、筆者は、
			    $\displaystyle |\bigcap_{S \in A} \overline{S}| = |\overline{\bigcup_{S \in A} S}| = \sum_{B \subseteq A} (-1)^{|B|} |\bigcap_{S \in B} S|$
			    という式の形で考えることが多い。<br>
			    つまり、$|S|$個の禁止事項があるときに全ての禁止事項を避けるような場合の数を求めたい場合、
			    禁止事項の部分集合に<b>違反する</b>(部分集合に入らない事項に関しては<b>全く気にしない</b>)ような場合の数を求めることができれば、元の問題の場合の数を求めることができる
			</li>
			<li>また、上式でいう$|\bigcap_{S \in B} S|$が$B$の要素数のみによって決まる場合などに(たとえば$f(n)$が$|B| = n$のときの値だとすると)、
			    $\displaystyle = \sum_{n=0}^{|A|} (-1)^n \binom{|A|}{n} f(n)$
			    といった形で使われることも多い。<br>
			    一般的な包除原理は時間計算量が指数なのに対し、この場合は多項式時間で求めることができるので重要である。<br>
			    また、上の条件を満たさない場合でもDPなどを利用することで多項式時間で包除原理をする問題もある。
			</li>
			<li>例：1～bの整数のうち、cでもdでも割り切れないものの数を数えよ</li>
			<ul>
			    <li>「cで割り切れる」「dで割り切れる」ことを避けなければならない禁止事項であると考える</li>
			    <li>まず、どの禁止事項も気にしない集合とは、1～bの全ての数の集合であり、その要素数はちょうど b である</li>
			    <li>次に、ちょうど1つに違反する場合とは、つまりそれぞれcで割り切れる場合とdで割り切れる場合である</li>
			    <li>最後に、2つ全てに違反する場合とは、cでもdでも割り切れる場合のことである</li>
			    <li>今回はc,dの2つであったが、これをk個に一般化することも簡単であり、$O(2^k k log b)$程度の計算量で解くことができる</li>
			</ul>
		</ul>
		<li>順序が関係ある。n個からk個取り出す組み合わせは nPk</li>
		<li>順序が関係ない。n個からk個取り出す組み合わせは nCk</li>
		<li>順序が関係ある。n個から全て取り出す組み合わせは n!</li>
		<li><a href="http://ja.wikipedia.org/wiki/%E3%83%91%E3%82%B9%E3%82%AB%E3%83%AB%E3%81%AE%E4%B8%89%E8%A7%92%E5%BD%A2" target="_blank">パスカルの三角形</a></li>
		<ul>
			<li>いわゆるコンビネーション　nCk　を計算するときに (n+1)段目の(k+1)番目の値である。</li>
			<li>二項定理などにも使える。</li>
		</ul>
	</ul>
</ul>
<ul>
	<li>計算量削減・枝刈り</li>
	<ul>
		<li><a href="http://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%A2%E5%8C%96">メモ化</a>・メモ化再帰</li>
		<ul>
			<li>過去に行った計算を保存しておき、一度した計算を行わないようにして計算量を削減する。</li>
			<li>「メモ化再帰」は、メモ化と再帰呼び出しを組み合わせたもの、TopCoder的には再帰する場合はメモ化再帰をよく使う。</li>
		</ul>
		<li><a href="http://ja.wikipedia.org/wiki/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95">動的計画法</a></li>
		<ul>
			<li>漸化式的に問題を解く。　（どのサイトも難しい説明をしてるけど、要はこういうこと</li>
			<li>（ただし、難しい説明がたくさんあるぐらいには色々な見方ができるのが動的計画法なのである）</li>
		</ul>
	</ul>
	<li>検索</li>
	<ul>
		<li>局所的最良検索</li>
		<ul>
			<li><a href="http://ja.wikipedia.org/wiki/%E8%B2%AA%E6%AC%B2%E6%B3%95">貪欲法</a></li>
		</ul>
		<li>全探索</li>
		<ul>
			<li><a href="http://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2">深さ優先検索</a>（DFS)</li>
			<li><a href="http://ja.wikipedia.org/wiki/%E5%B9%85%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2">幅優先探索</a>(BFS)</li>
		</ul>
		<li>二分探索</li>
		<ul>
			<li>範囲を半分ごとに縮めていくアルゴリズム、通常の探索ではO(n)となるところをlog(n)に出来たりする。</li>
		</ul>
	</ul>
</ul>
<ul>
	<li>最小コスト経路</li>
	<ul>
		<li><a href="http://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95">ダイクストラ法</a></li>
		<ul>
			<li>指定した２点間の最小経路コスト計算アルゴリズム（負の長さの枝があると低速になる可能性があることに注意）</li>
		</ul>
		<li><a href="http://ja.wikipedia.org/wiki/%E3%83%AF%E3%83%BC%E3%82%B7%E3%83%A3%E3%83%AB-%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89%E6%B3%95">ワーシャル-フロイド法</a></li>
		<ul>
			<li>任意のノード間の最小経路コスト計算アルゴリズム</li>
		</ul>
		<li>ベルマンフォード</li>
		<ul>
			<li>負閉路がある可能性がある場合や不閉路の検出に（ワーシャルフロイドでもできるがワーシャルフロイドでは遅い場合に）</li>
		</ul>
		<li>動的計画法</li>
		<ul>
			<li>DAGの場合は動的計画法が高速。DAGでなければ難しい（実際には体力は常に減っていく所持金は常に減っていくなどの関係があればDAGになるのでDAGになることも多い）</li>
		</ul>
	</ul>
	<li>累積和手法（いもす法）</li>
		<ul>
			<li><a href="http://imoz.jp/algorithms/imos_method.html">http://imoz.jp/algorithms/imos_method.html</a></li>
		</ul>
	<li>ゲーム</li>
	<ul>
		<li><a href="http://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%A0">Nim</a></li>
		<ul>
			<li>複数の山があり、それぞれの山には何個か物がある、同じ山からなら１個以上物が取れる、最後の１個をとった人が勝つゲーム</li>
			<li>簡単に計算できる必勝法が存在し、ある問題がNimに帰着できると簡単に答えが出せる。</li>
			<li>最後の一個をとった人が負けになるパターン（逆型）もあるが、簡単に答えは出せないらしい。</li>
		</ul>
		<li>Grundy数</li>
		<ul>
			<li>2人で交互に行動し、行動できなくなったら負けというタイプのゲームに定義される量。</li>
		</ul>
	</ul>
	<li>幾何</li>
	<ul>
		<li>点の多角形に対する内外判定</li>
		<ul>
			<li><a href="http://www.nttpc.co.jp/company/r_and_d/technology/number_algorithm.html">http://www.nttpc.co.jp/company/r_and_d/technology/number_algorithm.html</a></li>
			<li>なお、点から半直線を引いて何回交わるかというのは、多角形の線分の上をべたーっと通るとまずい（あるいは面倒な）ので、ランダムな方向に引くか、最初に図形をランダムな角度だけ回転しておくと良い（最初にランダムな角度回転する手法は、$x$ 座標が全て等しいケースがコーナーケースになるなどという場合にも回避できるので競技プログラミングでは汎用的に使えるコーナーケース回避策）</li>
			<li>Arccosを使う方法は、遅く、問題に寄っては普通にTLEになる。また、誤差の蓄積も激しく、0かどうかの判定は絶対値が $\pi$ 以下かどうかとしたほうが良いぐらいに激しい（閾値を0.1にするなどではぬるい、EPSなんてもってのほか！）。</li>
		</ul>
	</ul>
</ul>