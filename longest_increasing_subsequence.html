<h3>最長増加部分列問題 (LIS) について</h3>
<h4>最長増加部分列問題とは？</h4>
<p>最長増加部分列問題は、次のような有名問題です。</p>
<ul>
    <li>長さ $N$ の数列 $A_1, A_2, A_3, \dots, A_N$ が入力されるとき、そのうちいくつかの値を<b>順番を変えずに</b>取り出したときに、これが増加列となる中で最大の長さのものを求めなさい。</li>
    <li>数列 $b_1, b_2, b_3, \dots, b_k$ が「増加列」であるとは、$b_1 \leq b_2 \leq b_3 \leq \cdots \leq b_N$ が成り立つことである。</li>
</ul>
<p>例えば、次のような例があります。</p>
<ul>
    <li>$N = 7, A = (3, 5, 2, 6, 7, 1, 4)$ のとき、最長増加部分列は $(3, 5, 6, 7)$</li>
    <li>$N = 9, A = (3, 6, 9, 2, 5, 8, 1, 4, 7)$ のとき、最長増加部分列は $(3, 6, 9)$ や $(2, 5, 7)$、$(3, 5, 8)$ などたくさんあります。</li>
</ul>
<p>この記事では、最長増加部分列問題を通して、いろいろな問題と解法に触れていこうと思います。</p>
<br />
<h4>最長増加部分列の解法</h4>
<h5 class="shadow">解法 #1: $2^N$ 通り全探索</h5>
<p>長さ $N$ の数列の「部分列」(数列のいくつかの値を順番を変えずに取り出した数列) は、"長さ $0$ の数列" を含めて $2^N$ 通りあります。</p>
<p>例えば、数列 $(2, 6, 1)$ の部分列は、$(), (2), (6), (1), (2, 6), (2, 1), (6, 1), (2, 6, 1)$ の $8 = 2^3$ 通りあります。</p>
<br />
<p>なぜ部分列は $2^N$ 通りあるのでしょうか？</p>
<p>数列のいくつかの値に丸を付けて、丸がつけられた数を左から読んだのが「部分列」というイメージで考えます。</p>
<p>それぞれの値は丸をつけられるかつけられないかの $2$ 通りなので、全部で $2 \times 2 \times \cdots \times 2 = 2^N$ 通りです。</p>
<br />
<p>どのように $2^N$ 通り全探索することができるのでしょうか？これには $2$ つの方法があります。</p>
<ul>
    <li>再帰を使った全探索</li>
    <li>$2$ 進数を使った全探索</li>
</ul>
<br />
<p>まず、再帰を使った全探索について説明します。実装すると、下のようなコードになります。</p>
<pre>
ans = 0
function solve(pos, seq):
    if pos == N:
        if seq が増加部分列:
            ans := max(ans, seq の長さ)
        return
    solve(pos + 1, seq)
    solve(pos + 1, seq の末尾に A[pos] を追加したもの)
</pre>
<p><code>solve(0, [])</code> を呼び出すと、計算が始まります。<code>pos</code> は「現在選ぶかどうか決めようとしている数が <code>A[pos]</code>」、<code>seq</code> は「現在の部分列」です。</p>
<p>その擬似コードの $4$～$6$ 行目は、選ぶ部分列が決まった場合の処理です。つまり、$4$～$6$ 行目を $2^N$ 回通ります。</p>
<p>7, 8 行目の意味は、<code>A[pos]</code> を選ぶか選ばないかで枝分かれする、という意味です。その第 $1$ 引数が <code>pos+1</code> になっているのは、<code>A[pos]</code> を選ぶかどうか決める次に <code>A[pos+1]</code> を選ぶかどうか決める、からである。</p>
<br />
<p>次に、$2$ 進数を利用した全探索について説明します。実装すると、下のようなコードになります。</p>
<pre>
ans = 0
for i = 0 to 2^N-1:
    seq = []
    for j = 0 to N-1:
        if (i を 2 進数で表したときの 2^j の位が 1 である):
            seq := (seq の末尾に A[j] を追加したもの)
    if seq が増加部分列:
        ans := max(ans, seq の長さ)
</pre>
<p>例えば、$N=3$ のとき。$0$～$7$ までの数を $2$ 進数で表すと <code>000, 001, 010, 011, 100, 101, 110, 111</code> となります。ここで「$1$」となっいる桁に対応する数に丸を付け、「$0$」となっている桁に対応する数には丸をつけない、という感じです。</p>
<p>すると、ありうる $2^N$ 通りすべての部分列 <code>seq</code> について調べることができます。</p>
<br />
<p>計算量は、両者ともに $2^N$ 通りすべてに対して増加部分列判定をするので、$O \left(2^N \times N \right)$ です。</p>
<p>初心者にとって再帰を理解するのは難しいと思うので、$2$ 進数を利用した全探索の方が分かりやすいでしょう。実装量は両方そんなに変わりません。</p>